1. mysql事务需要遵守的4个特性
   + 原子性（Atomicity），通过undo log来保证
   + 一致性（Consistency）事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态，通过持久性+原子性+隔离性来保证
   + 隔离性（Isolation）并发事务执行时，防止多个事务交叉执行而导致的数据不一致，通过MVCC多版本并发控制或锁机制来保证
   + 持久性（Durability）事务处理结束后，对数据的修改时永久的，通过redo log来保证
2. SQL标准提出了四种隔离级别来规避脏读、不可重复读、幻读的问题
   + 读未提交（read uncommmitted），指一个事务还没提交时，它做的变更就能被其他事务看到
   + 读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到，于是每个语句执行前都会生成一个read view
   + 可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB引擎的默认隔离级别，于是在启动事务时生成一个read view快照，整个事务期间都用这个快照
   + 串行化（serializable），会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行
3. 开始事务的两种方式
   + begin/start transaction命令，执行命令后不立刻开启事务，执行第一条select才是真正启动
   + start transaction with consistent snapshot命令，立刻启动事务
4. 避免幻读但没法完全解决，都跟update有关
   + 针对快照读（普通select语句），是通过MVCC的方式解决了幻读
   + 针对当前读（select ... for update等语句），是通过next-key lock（记录锁+间隙锁）方式解决了幻读
   + 漏网之鱼
     + 其一
       + ![发生幻读的情况](./img/幻读发生.drawio.png)
       + 事务中看不到某条记录，在另一个事务插入了该记录之后，当前事务又更新了这一条记录，此时再查询就会有输出
     + 其二
       + 两次读条件范围的记录条数中，另一事务插入了一条符合条件范围的记录，此时两次得到的记录条数不一致
     + 如何避免
       + 在开启事务之后，马上执行select ... for update这类当前读的语句，因为会对记录加next-key lock