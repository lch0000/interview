1. mysql里的几种锁
   + 全局锁
     + FTWRL，加锁后整个数据库处于只读状态，主要应用于全库逻辑备份
       + 加锁 flush tables with read lock
       + 释放锁 unlock tables
       + 可以在备份数据库时先开启事务，先创建read view，这样不会影响数据库的表更新
       + 在mysqldump时加上-single-transaction参数，只适用于InnoDB存储引擎
   + 表级锁
     + 表锁
       + 读锁 lock tables t_student read
       + 写锁 lock tables t_student write
       + 解锁 unlock tables
       + 需要注意，表锁也会限制本线程接下来的读写操作
     + 元数据锁
       + 当线程在执行select语句（加MDL读锁）期间，如果其他线程要更改表结构，那么将会被阻塞，直到执行完select语句
       + 当有线程对表结构进行变更（加MDL写锁）的期间，如果有其他线程执行了CRUD操作，那么就会被阻塞，直到表结构变更完成
     + 意向锁
       + 如果没有意向锁，那么加独占表锁时，就需要遍历表里所有的记录，查看是否有记录存在独占锁
       + 如果有意向锁，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加独占表锁时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录了
       + 意向锁的目的是为了快速判断表里是否有记录被加锁
     + AUTO-INC锁
       + 执行完插入语句后就会立即释放
       + AUTO-INC锁在对大量数据进行插入的时候，会影响插入性能，于是在mysql 5.1.22版本开始，InnoDB存储引擎提供了一种轻量级的锁来实现自增，申请自增主键后就释放，不需要等语句执行后才释放
       + innodb_autoinc_lock_mode = 2采用轻量级锁，配合binlog_format = row来使用，既能提升并发性，又不会出现数据一致性问题
   + 行级锁
     + 共享锁（S锁），独占锁（X锁）
     + Record Lock 记录锁，把一条记录锁上
     + Gap Lock 间隙锁，锁定一个范围，但是不包含记录本身
     + Next-Key Lock 前边两种锁的组合，锁定一个范围，并且锁定记录本身
2. mysql是如何加锁的
   + 查询加锁
     + 对读取的记录加共享锁（S型锁）
       + select ... lock in share mode;
     + 对读取的记录加独占锁（x型锁）
       + select ... for update;
   + 更新和删除操作加锁
     + 更新时加独占锁（X型锁）
       + update table .... where id = 1;
     + 删除时加独占锁（X型锁）
       + delete from table where id = 1;
   + 加锁的对象是索引，加锁的基本单位是next-key lock
     + 在能使用记录锁或者间隙锁就能避免幻读现象的场景下，next-key lock会退化为记录锁或间隙锁
     + 唯一索引等值查询
       + 当查询的记录存在，在索引树上定位到这一条记录后，将该记录的索引中的next-key lock会退化成记录锁
       + 当查询的记录是不存在的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的next-key lock退化成间隙锁
       + 可以通过select * from performance_schema.data_locks\G;语句查看事务执行SQL过程中加了什么锁
         + LOCK_MODE为x，说明是next-key锁
         + LOCK_MODE为x,REC_NOT_GAP，说明是记录锁
         + LOCK_MODE为x,GAP，说明是间隙锁
       + 记录存在
         + 加记录锁，仅靠记录锁也能避免幻读问题
       + 记录不存在
         + 加间隙锁，间隙
         + 如何确定区间
           + LOCK_MODE是next-key锁或者间隙锁，那么LOCK_DATA就表示锁的范围，右边界
           + 锁范围的左边界是表中的上一条记录值的id
         + 锁是加在索引上的，该场景下查询的记录是不存在的，自然没办法锁住这条不存在的记录
     + 唯一索引范围查询
       + 会对每一个扫描到的索引加next-key锁
         + 大于等于的范围查询，因为存在等值的查询条件，如果等值查询的记录是存在于表中，那么该记录的索引中的next-key锁会退化成记录锁
         + 小于或小于等于
           + 条件值不在记录表中，扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化为间隙锁，其他扫描到的记录，都是在这些记录的索引上加next-key锁
           + 当条件值的记录在表中，如果是小于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁，如果小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引next-key锁不会退化成间隙锁
     + 非唯一索引等值查询
       + 记录不存在
       + 记录存在
     + 非唯一索引范围查询
       + 对二级索引加锁都是加next-key锁
       + 在主键上也会加上记录锁
     + 没有加索引的查询
       + 触发全表扫描，每一条记录上都加上next-key锁，类似于表锁
       + 一定要小心，不要产生表锁
3. 避免update时会锁全表
   + 可以打开mysql的sql_safe_updates参数，可以预防update操作时where条件没有带上索引列
   + 如果发现在where条件中戴上了索引列，优化器走的还是全表扫描，这是可以使用force index([index_name])来告诉优化器使用哪个索引
4. 解决幻读的问题
   + 幻读的定义
     + 当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果select执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻象”行
   + 在InnoDB引擎的默认隔离级别可重复读下，是如何很大程度解决幻读现象的
     + 针对快照读（普通select语句），是通过MVCC方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟着这个事务启动时看到的数据是一致的
     + 针对当前读（select ... for update等语句），是通过next-key lock（记录锁+间隙锁）方式解决了幻读
5. 发生死锁的条件，如何解决
   + 死锁案例
     + ![死锁案例](/interview/mysql/img/死锁案例.png)
     + 插入意向锁和间隙锁是冲突的
     + 间隙锁和间隙锁是兼容的，两个事务中的select ... for update语句并不会相互影响
       + 间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互补冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁
     + 范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突，因为+∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系
     + 插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作
     + mysql加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁
   + insert语句是怎么加行级锁的
     + insert语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的trx_id隐藏列来作为隐式锁保护记录的
       + 如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的
       + 如果insert的记录和已有记录存在唯一键冲突，此时也不能插入记录
6. 如何避免死锁
   + 死锁的四个必要条件，只要系统发生死锁，这些条件必然成立，但只要破坏任意一个条件，死锁就不会成立
     + 互斥
     + 占有且等待
     + 不可强占用
     + 循环等待
   + 打破死锁的策略
     + 设置事务等待锁的超时时间
       + innodb_lock_wait_timeout用来设置超时时间，默认值50秒
       + 当一个事务等待时间超过该值后，就对这个事务进行回滚
       + 出现Lock wait timeout exceeded;try restarting transaction报错
     + 开启主动死锁检测
       + 主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行
       + 将innodb_deadlock_detect设置为on，表示开启主动死锁检测
       + Deadlock found when trying to get lock;try restarting transaction
     + 将订单编号设置为唯一索引列，从而保证订单表不会出现重复的订单